<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 环形轨道</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xeeeeee); // 设置背景色为浅灰色

        // 创建环形轨道，先变成横向的，再倾斜
        const torusGeometry = new THREE.TorusGeometry(8, 0.05, 16, 100); // 增大环形轨道的半径
        const torusMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.rotation.x = Math.PI / 2; // 先旋转90度，使其横向
        torus.rotation.x += Math.PI / 9; // 再绕x轴旋转20度
        torus.rotation.z = Math.PI / 9; // 绕z轴旋转20度
        scene.add(torus);

        // 添加放大的正方形
        const boxGeometry = new THREE.BoxGeometry(1, 1, 1); // 放大正方形
        const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

        const boxes = [];
        for (let i = 0; i < 10; i++) {
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            const angle = (i / 10) * Math.PI * 2;
            box.userData.angle = angle; // 存储每个正方形的初始角度
            box.position.set((8 + 0.5) * Math.cos(angle), (8 + 0.5) * Math.sin(angle), 0); // 沿环形轨道放置
            torus.add(box); // 将正方形添加到环形轨道上
            boxes.push(box);
        }

        // 添加光源
        const pointLight = new THREE.PointLight(0xffffff, 2, 100); // 增加光源强度
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        scene.add(new THREE.AmbientLight(0x404040)); // 环境光

        camera.position.z = 25; // 调整相机位置

        // 确保相机朝向轨道
        camera.lookAt(torus.position);

        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                const rotationSpeed = 0.005;
                const rotation = deltaMove.x * rotationSpeed;

                boxes.forEach(box => {
                    box.userData.angle += rotation;
                    const newX = (8 + 0.5) * Math.cos(box.userData.angle);
                    const newY = (8 + 0.5) * Math.sin(box.userData.angle);
                    box.position.set(newX, newY, 0);
                });
            }

            previousMousePosition = {
                x: e.offsetX,
                y: e.offsetY
            };
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>